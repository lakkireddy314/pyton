Below is the complete updated deliverable:

✅ compile.yml logic is now inside the role (as part of gather_stats.yml)

✅ Conflict detection + deterministic resolution

✅ NEW improvement: conflict hints (actionable guidance per conflict) published into intent stats

✅ Full role contents + playbooks, Ansible 2.9 compatible

✅ Features + how it works explained (brief but clear)

What changed (high level)
1) Compile is now part of role gather_stats

pipeline.yml runs venafi_cert_renew_pipeline/tasks/gather_stats.yml first (tagged always)

gather_stats.yml imports compile_intent.yml (which scans all inventory hosts)

2) Conflicts are handled correctly

Detects duplicate cert definitions across hosts

Resolves deterministically:

deploy_hosts = union of hosts referencing that cert (always)

renew_days = max() across definitions (conservative)

keystore_type = union unique list

scalar fields resolved by preference: prefer_first or prefer_last

Publishes:

compile_conflicts[]

compile_conflict_count

NEW: compile_conflict_hints[] (what to do next)

3) Conflict hints (new improvement)

For each conflict, the role generates a recommended fix, like:

“Make deploy_dir consistent; if per-env/per-host, move to cert_deploy_matrix”

“pickup_id should usually be global; keep it in one place”

Full file tree
playbooks/
  compile.yml
  pipeline.yml

roles/
  venafi_cert_renew_pipeline/
    defaults/
      main.yml
    tasks/
      gather_stats.yml
      compile_intent.yml
      compile_one_cert.yml
      conflict_hints.yml

      precheck.yml
      precheck_standalone.yml
      precheck_per_cert.yml

      renew.yml
      renew_standalone.yml
      renew_per_cert.yml
      renew_report.yml

      deploy.yml
      deploy_from_stats.yml
      deploy_standalone.yml
    templates/
      report_dry.html.j2
      report_renew.html.j2

PLAYBOOKS
playbooks/pipeline.yml (runs gather first, then stages by tags)
---
- hosts: localhost
  gather_facts: false

  vars:
    vcert_bin: "/usr/local/bin/vcert"
    openssl_bin: "/usr/bin/openssl"
    keytool_bin: "/usr/bin/keytool"
    expected_validity_days: 730

    pipeline_intent_var: "venafi_pipeline_intent"
    pipeline_stats_var:  "venafi_pipeline_stats"
    venafi_policy_prefix: "/ved/policy/Automated/certs"

    renew_report: true
    smtp_host: "mail.yourorg.internal"
    smtp_port: 25
    user_email: "tls-ops@yourorg.com"

    deploy_stage_root: "/tmp/venafi_deploy"
    deploy_user: "wasadmin"
    deploy_group: "was"
    deploy_dir: "/home/user/Ansible_renewedCerts"
    deploy_keystore_type: ["pem"]

    require_intent: false

    # compile/conflict controls
    gather_compile_intent: true
    compile_conflict_mode: "warn"          # warn|fail
    compile_conflict_prefer: "prefer_first" # prefer_first|prefer_last

  tasks:
    - name: pipeline | gather stats (compile + fold + validate) FIRST
      include_role:
        name: venafi_cert_renew_pipeline
        tasks_from: gather_stats.yml
      tags: [always]

    - name: pipeline | precheck
      include_role:
        name: venafi_cert_renew_pipeline
        tasks_from: precheck.yml
      vars:
        compiled_cert_plan: "{{ compiled_cert_plan | default({}) }}"
        cert_names:          "{{ cert_names          | default([]) }}"
      tags: [precheck]

    - name: pipeline | renew
      include_role:
        name: venafi_cert_renew_pipeline
        tasks_from: renew.yml
      vars:
        compiled_cert_plan: "{{ compiled_cert_plan | default({}) }}"
        cert_names:          "{{ cert_names          | default([]) }}"
      tags: [renew]

    - name: pipeline | deploy
      include_role:
        name: venafi_cert_renew_pipeline
        tasks_from: deploy.yml
      vars:
        compiled_cert_plan: "{{ compiled_cert_plan | default({}) }}"
        cert_names:          "{{ cert_names          | default([]) }}"
      tags: [deploy]

playbooks/compile.yml (optional wrapper, compile-only job)

Useful if you still want a dedicated AWX node just to compile intent artifacts.

---
- hosts: localhost
  gather_facts: false
  tasks:
    - name: compile | compile intent via role gather_stats (compile-only)
      include_role:
        name: venafi_cert_renew_pipeline
        tasks_from: gather_stats.yml
      vars:
        gather_compile_intent: true
        gather_validate_intent: false
        require_intent: false
      tags: [always]

ROLE: roles/venafi_cert_renew_pipeline/
defaults/main.yml
---
pipeline_intent_var: "venafi_pipeline_intent"
pipeline_stats_var:  "venafi_pipeline_stats"

venafi_policy_prefix: "/ved/policy/Automated/certs"

vcert_bin:   "/usr/local/bin/vcert"
openssl_bin: "/usr/bin/openssl"
keytool_bin: "/usr/bin/keytool"

expected_validity_days: 730
renew_days: 90

renew_report: true
smtp_host: ""
smtp_port: 25
user_email: ""

deploy_stage_root: "/tmp/venafi_deploy"
deploy_user:  "wasadmin"
deploy_group: "was"
deploy_dir:   "/home/user/Ansible_renewedCerts"
deploy_keystore_type: ["pem"]

deploy_after_renew: false

# --- gather/compile behavior ---
gather_compile_intent: true
gather_validate_intent: true

# --- conflict handling ---
compile_conflict_mode: "warn"            # warn|fail
compile_conflict_prefer: "prefer_first"  # prefer_first|prefer_last

tasks/gather_stats.yml
---
- name: gather_stats | compile intent from inventory (optional)
  when: gather_compile_intent | default(true) | bool
  import_tasks: compile_intent.yml
  tags: [always]

- name: gather_stats | fold intent artifacts if present
  set_fact:
    compiled_cert_plan: "{{ (hostvars['localhost'][pipeline_intent_var].compiled_cert_plan | default({})) }}"
    cert_names:          "{{ (hostvars['localhost'][pipeline_intent_var].cert_names          | default([])) }}"
  when: hostvars['localhost'][pipeline_intent_var] is defined
  run_once: true
  delegate_to: localhost
  tags: [always]

- name: gather_stats | ensure defaults if intent absent
  set_fact:
    compiled_cert_plan: "{{ compiled_cert_plan | default({}) }}"
    cert_names: "{{ cert_names | default([]) }}"
  when: hostvars['localhost'][pipeline_intent_var] is not defined
  run_once: true
  delegate_to: localhost
  tags: [always]

- name: gather_stats | detect requested stages (from tags)
  set_fact:
    __want_pre: "{{ 'precheck' in ansible_run_tags or (ansible_run_tags | length == 0) }}"
    __want_ren: "{{ 'renew' in ansible_run_tags }}"
    __want_dep: "{{ 'deploy' in ansible_run_tags }}"
  run_once: true
  delegate_to: localhost
  tags: [always]

- name: gather_stats | validator (require intent unless standalone)
  when: gather_validate_intent | default(true) | bool
  assert:
    that:
      - >
        not (require_intent | default(false) | bool) or
        (
          (not __want_pre or (precheck_mode | default('auto')) == 'standalone')
          and
          (not __want_ren or (renew_mode    | default('auto')) == 'standalone')
          and
          (not __want_dep or (deploy_mode   | default('auto')) == 'standalone')
        )
        or
        (
          hostvars['localhost'][pipeline_intent_var] is defined
          and (hostvars['localhost'][pipeline_intent_var].compiled_cert_plan | default({}) | length) > 0
        )
  fail_msg: >
    This job expects intent artifacts but none were found.
    Either enable gather_compile_intent=true (compile inside pipeline),
    or run a compile step first and enable “Pass artifacts”,
    or run this stage in standalone mode.
  run_once: true
  delegate_to: localhost
  tags: [always]

tasks/compile_intent.yml
---
- name: compile_intent | init
  set_fact:
    __defs: []
    __plan: {}
    __conflicts: []
    __conflict_hints: []
    __hosts_sorted: "{{ (groups['all'] | default([])) | sort }}"
  run_once: true
  delegate_to: localhost

- name: compile_intent | collect definitions from inventory hosts
  vars:
    _vh: "{{ hostvars[item] | default({}) }}"
    _src: "{{ _vh.venafi_renew_certs | default({}) }}"
    _items: "{{ _src | dict2items }}"
  loop: "{{ __hosts_sorted }}"
  loop_control: { loop_var: item }
  when: (_src | length) > 0
  set_fact:
    __defs: "{{ __defs + (_items | map('combine', {'host': item}) | list) }}"
  run_once: true
  delegate_to: localhost

- name: compile_intent | unique cert list
  set_fact:
    __certs: "{{ (__defs | map(attribute='key') | list | unique) }}"
  run_once: true
  delegate_to: localhost

- name: compile_intent | compile per cert (conflict-aware)
  include_tasks: compile_one_cert.yml
  loop: "{{ __certs }}"
  loop_control:
    loop_var: cert
    label: "{{ cert }}"
  vars:
    _defs_for_cert: "{{ __defs | selectattr('key','equalto', cert) | list }}"
  run_once: true
  delegate_to: localhost

# NEW: generate actionable hints for conflicts
- name: compile_intent | build conflict hints
  when: (__conflicts | length) > 0
  import_tasks: conflict_hints.yml
  run_once: true
  delegate_to: localhost

- name: compile_intent | publish intent + conflicts + hints via set_stats (aggregate)
  set_stats:
    data:
      "{{ pipeline_intent_var }}": >-
        {{
          (hostvars['localhost'][pipeline_intent_var] | default({}))
          | combine({
              'compiled_cert_plan': __plan,
              'cert_names': (__plan.keys() | list),
              'compile_conflicts': __conflicts,
              'compile_conflict_count': (__conflicts | length),
              'compile_conflict_hints': (__conflict_hints | default([]))
            }, recursive=True)
        }}
    aggregate: true
  run_once: true
  delegate_to: localhost

- name: compile_intent | set runtime handles for same job
  set_fact:
    compiled_cert_plan: "{{ __plan }}"
    cert_names: "{{ __plan.keys() | list }}"
  run_once: true
  delegate_to: localhost

- name: compile_intent | conflict summary (warn mode)
  when: (compile_conflict_mode | default('warn')) == 'warn' and (__conflicts | length) > 0
  debug:
    msg:
      - "WARNING: compile detected {{ __conflicts | length }} conflict(s)."
      - "Hints: {{ __conflict_hints | default([]) | length }} suggestion(s) generated."
      - "See: {{ pipeline_intent_var }}.compile_conflicts and compile_conflict_hints."
  run_once: true
  delegate_to: localhost

- name: compile_intent | fail on conflicts (fail mode)
  when: (compile_conflict_mode | default('warn')) == 'fail' and (__conflicts | length) > 0
  assert:
    that: [ "false" ]
    fail_msg: >
      compile_intent found {{ __conflicts | length }} conflict(s) across inventory hosts.
      Fix duplicates or set compile_conflict_mode=warn to continue.
  run_once: true
  delegate_to: localhost

tasks/compile_one_cert.yml
---
- name: compile_one_cert | init normalized list
  set_fact:
    __n: []
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | normalize per host definition
  loop: "{{ _defs_for_cert }}"
  loop_control:
    loop_var: d
    label: "{{ d.host }}"
  vars:
    _raw: "{{ d.value }}"
    _def: >-
      {{
        (_raw[0] if (_raw is sequence and (_raw is not string) and (_raw|length)>0) else (_raw | default({})))
        if (_raw is not string) else {}
      }}
  set_fact:
    __n: "{{ __n + [ {'host': d.host, 'def': (_def | default({})) } ] }}"
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | init accumulators
  set_fact:
    __hosts: []
    __kt: []
    __renew_vals: []
    __pickup_src: []
    __dir_src: []
    __user_src: []
    __group_src: []
    __app_src: []
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | accumulate fields
  loop: "{{ __n }}"
  loop_control:
    loop_var: x
    label: "{{ x.host }}"
  vars:
    _d: "{{ x.def | default({}) }}"

    _pickup: "{{ (_d.pickup_id | default('')) | string }}"
    _dir:    "{{ (_d.deploy_dir | default('')) | string }}"
    _user:   "{{ (_d.deploy_user | default('')) | string }}"
    _group:  "{{ (_d.deploy_group | default('')) | string }}"
    _app:    "{{ (_d.cert_app_config | default('')) | string }}"

    _renew:  "{{ (_d.renew_days | default('')) }}"
    _kt_raw: "{{ _d.keystore_type | default(omit) }}"
  set_fact:
    __hosts: "{{ __hosts + [ x.host ] }}"

    __pickup_src: "{{ __pickup_src + ( (_pickup | length) > 0 | ternary([{'host': x.host, 'value': _pickup}], []) ) }}"
    __dir_src:    "{{ __dir_src    + ( (_dir    | length) > 0 | ternary([{'host': x.host, 'value': _dir   }], []) ) }}"
    __user_src:   "{{ __user_src   + ( (_user   | length) > 0 | ternary([{'host': x.host, 'value': _user  }], []) ) }}"
    __group_src:  "{{ __group_src  + ( (_group  | length) > 0 | ternary([{'host': x.host, 'value': _group }], []) ) }}"
    __app_src:    "{{ __app_src    + ( (_app    | length) > 0 | ternary([{'host': x.host, 'value': _app   }], []) ) }}"

    __renew_vals: "{{ __renew_vals + ( (_renew | string | length) > 0 | ternary([ (_renew | int) ], []) ) }}"

    __kt: >-
      {{
        __kt
        + (
            (_kt_raw is defined)
            | ternary(
                (
                  (_kt_raw is string)
                  | ternary([_kt_raw], (_kt_raw if (_kt_raw is sequence) else []))
                ),
                []
              )
          )
      }}
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | unique sets
  vars:
    _pickup_vals: "{{ __pickup_src | map(attribute='value') | list | unique }}"
    _dir_vals:    "{{ __dir_src    | map(attribute='value') | list | unique }}"
    _user_vals:   "{{ __user_src   | map(attribute='value') | list | unique }}"
    _group_vals:  "{{ __group_src  | map(attribute='value') | list | unique }}"
    _app_vals:    "{{ __app_src    | map(attribute='value') | list | unique }}"
  set_fact:
    __pickup_vals: "{{ _pickup_vals }}"
    __dir_vals:    "{{ _dir_vals }}"
    __user_vals:   "{{ _user_vals }}"
    __group_vals:  "{{ _group_vals }}"
    __app_vals:    "{{ _app_vals }}"
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | resolve chosen scalar values
  vars:
    _prefer_last: "{{ (compile_conflict_prefer | default('prefer_first')) == 'prefer_last' }}"
    _prefix: "{{ venafi_policy_prefix | default('/ved/policy/Automated/certs') }}"

    _pickup_chosen: >-
      {{
        (__pickup_src | sort(attribute='host') | map(attribute='value') | list)[-1]
        if (_prefer_last and (__pickup_src | length) > 0)
        else (
          (__pickup_src | sort(attribute='host') | map(attribute='value') | list)[0]
          if ((__pickup_src | length) > 0) else (_prefix ~ '/' ~ cert)
        )
      }}

    _dir_chosen: >-
      {{
        (__dir_src | sort(attribute='host') | map(attribute='value') | list)[-1]
        if (_prefer_last and (__dir_src | length) > 0)
        else (
          (__dir_src | sort(attribute='host') | map(attribute='value') | list)[0]
          if ((__dir_src | length) > 0) else (deploy_dir | default('/home/user/Ansible_renewedCerts'))
        )
      }}

    _user_chosen: >-
      {{
        (__user_src | sort(attribute='host') | map(attribute='value') | list)[-1]
        if (_prefer_last and (__user_src | length) > 0)
        else (
          (__user_src | sort(attribute='host') | map(attribute='value') | list)[0]
          if ((__user_src | length) > 0) else (deploy_user | default('wasadmin'))
        )
      }}

    _group_chosen: >-
      {{
        (__group_src | sort(attribute='host') | map(attribute='value') | list)[-1]
        if (_prefer_last and (__group_src | length) > 0)
        else (
          (__group_src | sort(attribute='host') | map(attribute='value') | list)[0]
          if ((__group_src | length) > 0) else (deploy_group | default('was'))
        )
      }}

    _app_chosen: >-
      {{
        (__app_src | sort(attribute='host') | map(attribute='value') | list)[-1]
        if (_prefer_last and (__app_src | length) > 0)
        else (
          (__app_src | sort(attribute='host') | map(attribute='value') | list)[0]
          if ((__app_src | length) > 0) else ''
        )
      }}
  set_fact:
    __pickup_chosen: "{{ _pickup_chosen }}"
    __dir_chosen: "{{ _dir_chosen }}"
    __user_chosen: "{{ _user_chosen }}"
    __group_chosen: "{{ _group_chosen }}"
    __app_chosen: "{{ _app_chosen }}"
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | resolve renew/keystore
  vars:
    _renew_chosen: "{{ (__renew_vals | length) > 0 | ternary((__renew_vals | max), (renew_days | default(90) | int)) }}"
    _kt_chosen:    "{{ (__kt | length) > 0 | ternary((__kt | unique | list), (deploy_keystore_type | default(['pem'])) ) }}"
  set_fact:
    __renew_chosen: "{{ _renew_chosen | int }}"
    __kt_chosen: "{{ _kt_chosen | list }}"
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | add conflicts (scalar fields)
  set_fact:
    __conflicts: >-
      {{
        __conflicts
        + (
            (__pickup_vals | length > 1)
            | ternary([{'cert': cert, 'field': 'pickup_id', 'sources': __pickup_src, 'chosen': __pickup_chosen}], [])
          )
        + (
            (__dir_vals | length > 1)
            | ternary([{'cert': cert, 'field': 'deploy_dir', 'sources': __dir_src, 'chosen': __dir_chosen}], [])
          )
        + (
            (__user_vals | length > 1)
            | ternary([{'cert': cert, 'field': 'deploy_user', 'sources': __user_src, 'chosen': __user_chosen}], [])
          )
        + (
            (__group_vals | length > 1)
            | ternary([{'cert': cert, 'field': 'deploy_group', 'sources': __group_src, 'chosen': __group_chosen}], [])
          )
        + (
            (__app_vals | length > 1)
            | ternary([{'cert': cert, 'field': 'cert_app_config', 'sources': __app_src, 'chosen': __app_chosen}], [])
          )
      }}
  run_once: true
  delegate_to: localhost

- name: compile_one_cert | update compiled plan (deploy_hosts union)
  set_fact:
    __plan: >-
      {{
        __plan | combine({
          (cert): {
            'pickup_id': __pickup_chosen,
            'renew_days': (__renew_chosen | int),
            'keystore_type': (__kt_chosen | list),
            'deploy_dir': __dir_chosen,
            'deploy_user': __user_chosen,
            'deploy_group': __group_chosen,
            'cert_app_config': __app_chosen,
            'deploy_hosts': (__hosts | unique | list)
          }
        }, recursive=True)
      }}
  run_once: true
  delegate_to: localhost

NEW improvement: tasks/conflict_hints.yml

This turns conflicts into actionable guidance you can show in reports or debug.

---
- name: conflict_hints | init
  set_fact:
    __conflict_hints: []
  run_once: true
  delegate_to: localhost

- name: conflict_hints | build hint per conflict
  loop: "{{ __conflicts }}"
  loop_control:
    loop_var: c
    label: "{{ c.cert }}:{{ c.field }}"
  vars:
    _field: "{{ c.field | default('') }}"
    _msg: >-
      {{
        (
          _field == 'deploy_dir'
          | ternary(
              'deploy_dir differs across hosts. Recommendation: keep deploy_dir consistent in venafi_renew_certs; if it must vary by host/env, move overrides into cert_deploy_matrix (deploy stage) and keep venafi_renew_certs minimal.',
              ''
          )
        )
      }}
  set_fact:
    __conflict_hints: "{{ __conflict_hints + [ {
      'cert': c.cert,
      'field': c.field,
      'chosen': (c.chosen | default('')),
      'hosts': (c.sources | default([]) | map(attribute='host') | list),
      'hint': (
        _field == 'deploy_dir'
        | ternary(
            'deploy_dir differs across hosts. Recommendation: keep deploy_dir consistent in venafi_renew_certs; if it must vary by host/env, move overrides into cert_deploy_matrix (deploy stage).',
            (
              _field == 'deploy_user'
              | ternary('deploy_user differs. Recommendation: standardize deploy_user in one place (defaults/group_vars). If host-specific, prefer cert_deploy_matrix or group_vars for that host group.',
                (
                  _field == 'deploy_group'
                  | ternary('deploy_group differs. Recommendation: standardize deploy_group. If host-specific, use cert_deploy_matrix or group_vars by host/group.',
                    (
                      _field == 'pickup_id'
                      | ternary('pickup_id differs. Recommendation: pickup_id should typically be global per cert. Define it once (group_vars/all or a single host) to avoid renewing the wrong object.',
                        (
                          _field == 'cert_app_config'
                          | ternary('cert_app_config differs. Recommendation: treat as informational metadata; keep consistent or store host-specific metadata elsewhere (inventory vars) to avoid compile conflicts.',
                                   'Conflict detected. Recommendation: consolidate duplicate definitions for this cert.'
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
        )
      )
    } ] }}"
  run_once: true
  delegate_to: localhost

PRECHECK / RENEW / DEPLOY (unchanged from your current)

These are included here verbatim so you have full role contents.

tasks/precheck.yml
---
- name: precheck | decide mode
  set_fact:
    __mode_pc: "{{ (precheck_mode | default('auto')) }}"
  run_once: true
  delegate_to: localhost
  tags: [precheck]

- name: precheck | auto → standalone if standalone inputs present, else stats
  set_fact:
    __mode_pc: >-
      {{
        (__mode_pc == 'auto') |
        ternary(
          ((precheck_standalone_items | default([]) | length) > 0) or
          ((precheck_cert | default('')) | length > 0),
          'standalone',
          'stats'
        )
      }}
  run_once: true
  delegate_to: localhost
  tags: [precheck]

- name: precheck | standalone
  when: __mode_pc == 'standalone'
  import_tasks: precheck_standalone.yml
  tags: [precheck]

- name: precheck | stats/plan
  when: __mode_pc == 'stats'
  block:
    - name: precheck | assert inputs
      assert:
        that:
          - (compiled_cert_plan is defined and (compiled_cert_plan | length) > 0) or
            (cert_names is defined and (cert_names | length) > 0)
        fail_msg: "Precheck requires compiled_cert_plan or cert_names."
      run_once: true

    - name: precheck | working list
      set_fact:
        _pc_cert_list: >-
          {{
            (compiled_cert_plan.keys() | list)
            if (compiled_cert_plan is defined and compiled_cert_plan | length > 0)
            else cert_names
          }}
      run_once: true

    - name: precheck | per cert
      include_tasks: precheck_per_cert.yml
      loop: "{{ _pc_cert_list }}"
      loop_control: { loop_var: pc_cert }
      vars:
        pc_pickup_id: >-
          {{
            (compiled_cert_plan.get(pc_cert, {}).get('pickup_id'))
            | default( (venafi_policy_prefix | default('/ved/policy/Automated/certs')) ~ '/' ~ pc_cert )
          }}
        th_need: "{{ compiled_cert_plan.get(pc_cert, {}).get('renew_days', renew_days | default(90)) | int }}"
  tags: [precheck]

tasks/precheck_standalone.yml
---
- name: precheck(standalone) | defaults
  set_fact:
    __pc_prefix: "{{ venafi_policy_prefix | default('/ved/policy/Automated/certs') }}"
    __pc_default_days: "{{ (renew_days | default(90)) | int }}"
  run_once: true

- name: precheck(standalone) | normalize inputs
  set_fact:
    __pc_items: >-
      {{
        (precheck_standalone_items | default([]))
        if ((precheck_standalone_items | default([])) | length) > 0
        else
          (
            ((precheck_cert | default('')) | length) > 0
            | ternary(
                [ { 'cert': precheck_cert,
                    'pickup_id': (precheck_pickup_id | default('')),
                    'renew_days': (precheck_renew_days | default(__pc_default_days)) } ],
                [] )
          )
      }}

- name: precheck(standalone) | assert items
  assert:
    that:
      - __pc_items | length > 0
    fail_msg: "precheck(standalone): provide precheck_standalone_items or precheck_cert* vars."

- name: precheck(standalone) | run per cert
  loop: "{{ __pc_items }}"
  loop_control: { loop_var: pc }
  include_tasks: precheck_per_cert.yml
  vars:
    pc_cert: "{{ pc.cert }}"
    pc_pickup_id: "{{ (pc.pickup_id | default('')) | length > 0 | ternary(pc.pickup_id, (__pc_prefix ~ '/' ~ pc.cert)) }}"
    th_need: "{{ (pc.renew_days | default(__pc_default_days)) | int }}"

tasks/precheck_per_cert.yml
---
- name: precheck | ensure stats bucket
  set_stats:
    data:
      "{{ pipeline_stats_var }}": "{{ ((hostvars.get('localhost', {})).get(pipeline_stats_var, {})) | default({}) }}"
  run_once: true

- name: precheck | load stats handle
  set_fact:
    __psvar: "{{ pipeline_stats_var }}"
    __psobj: "{{ hostvars['localhost'][pipeline_stats_var] | default({}) }}"
  run_once: true

- name: precheck | vcert pickup raw
  command: >
    {{ vcert_bin }} pickup -id "{{ pc_pickup_id }}"
  register: __pc_pem_raw
  changed_when: false

- name: precheck | strip vcert logs
  set_fact:
    __pc_pem: "{{ __pc_pem_raw.stdout | regex_replace('(?m)^vcert:.*\\n', '') }}"

- name: precheck | serial
  shell: |
    set -o pipefail
    printf "%s" "{{ __pc_pem | quote }}" | {{ openssl_bin }} x509 -noout -serial
  register: __pc_serial_cmd
  changed_when: false

- name: precheck | enddate
  shell: |
    set -o pipefail
    printf "%s" "{{ __pc_pem | quote }}" | {{ openssl_bin }} x509 -noout -enddate
  register: __pc_end_cmd
  changed_when: false

- name: precheck | parse fields and days
  vars:
    _end_txt: "{{ (__pc_end_cmd.stdout | regex_replace('^notAfter=','')) | trim }}"
    _end_ts:  "{{ ( _end_txt | to_datetime('%b %d %H:%M:%S %Y %Z') ).timestamp() | int }}"
    _now:     "{{ (ansible_date_time.epoch | int) }}"
  set_fact:
    __pc_serial: "{{ (__pc_serial_cmd.stdout | regex_replace('^serial=','') | trim) | default('') }}"
    __pc_endtxt: "{{ _end_txt }}"
    __pc_days: "{{ (((_end_ts - _now)/86400) | round(0,'floor')) | int }}"

- name: precheck | derive status (no gaps)
  vars:
    _need: "{{ th_need | int }}"
    _exp_high: "{{ (th_need | int) + 30 }}"
  set_fact:
    __pc_status: >-
      {{
        (__pc_days | int) <= _need
        | ternary('need to renew',
                  (
                    (__pc_days | int) <= _exp_high
                    | ternary('expiring','no renewal needed')
                  )
        )
      }}

- name: precheck | publish stats
  set_stats:
    data:
      "{{ __psvar }}": >-
        {{
          __psobj | combine({
            'precheck': (__psobj.get('precheck',{}) | combine({
              (pc_cert): {
                'pickup_id': pc_pickup_id,
                'serial': __pc_serial,
                'end_text': __pc_endtxt,
                'days_remaining': __pc_days,
                'status': __pc_status
              }
            }, recursive=True))
          }, recursive=True)
        }}

tasks/renew.yml
---
- name: renew | resolve stats presence
  set_fact:
    __psvar: "{{ (pipeline_stats_var | default('venafi_pipeline_stats')) | string }}"
    __psobj: "{{ ((hostvars | default({})).get('localhost', {})).get(__psvar, {}) }}"
    __ps_available: "{{ (__psobj | length) > 0 }}"
  run_once: true
  delegate_to: localhost
  tags: [renew]

- name: renew | decide mode
  set_fact:
    __mode_rn: "{{ (renew_mode | default('auto')) }}"
  run_once: true
  delegate_to: localhost
  tags: [renew]

- name: renew | auto → standalone if inputs present or no stats
  set_fact:
    __mode_rn: >-
      {{
        (__mode_rn == 'auto') |
        ternary(
          ( (renew_standalone_items | default([]) | length) > 0 ) or
          ( (renew_cert | default('') | length) > 0 ) or
          ( not __ps_available ),
          'standalone', 'stats'
        )
      }}
  run_once: true
  delegate_to: localhost
  tags: [renew]

- name: renew | standalone
  when: __mode_rn == 'standalone'
  import_tasks: renew_standalone.yml
  tags: [renew]

- name: renew | stats/plan
  when: __mode_rn == 'stats'
  block:
    - name: renew | candidate list
      set_fact:
        _renew_cert_list: >-
          {{
            (compiled_cert_plan.keys() | list) if (compiled_cert_plan is defined and compiled_cert_plan | length > 0)
            else (
              (__psobj.precheck.keys() | list) if (__ps_available and (__psobj.precheck | default({}) | length) > 0)
              else ( cert_names if (not __ps_available) else (__psobj.renew.keys() | list) )
            )
          }}
        precheck_stats: "{{ __psobj.precheck | default({}) }}"
      run_once: true
      delegate_to: localhost

    - name: renew | restrict to need-to-renew unless forced
      when: __ps_available and (not (renew_force | default(false) | bool)) and (_renew_cert_list | length) > 0
      set_fact:
        _renew_cert_list: >-
          {{
            _renew_cert_list
            | select('in',
                 (__psobj.precheck | default({})
                   | dict2items
                   | selectattr('value.status','equalto','need to renew')
                   | map(attribute='key') | list)
                 )
            | list
          }}
      run_once: true
      delegate_to: localhost

    - name: renew | early-exit
      when: __ps_available and (not (renew_force | default(false) | bool)) and ((_renew_cert_list | default([])) | length) == 0
      block:
        - debug: { msg: "No certificates with status 'need to renew'. Skipping renew." }
        - meta: end_play
      run_once: true

    - name: renew | assert non-empty
      assert:
        that:
          - _renew_cert_list is defined
          - (_renew_cert_list | length) > 0
        fail_msg: "Renew stage has no certificates to process."
      run_once: true
      delegate_to: localhost

    - name: renew | per cert
      include_tasks: renew_per_cert.yml
      loop: "{{ _renew_cert_list }}"
      loop_control:
        loop_var: rn_cert
        label: "{{ rn_cert }}"
      vars:
        rn_pickup_id: >-
          {{
            (compiled_cert_plan.get(rn_cert, {}).get('pickup_id'))
            | default( (venafi_policy_prefix | default('/ved/policy/Automated/certs')) ~ '/' ~ rn_cert )
          }}
        rn_force: "{{ (renew_force | default(false) | bool) or (not __ps_available) }}"
        deploy_keystore_type: "{{ compiled_cert_plan.get(rn_cert, {}).get('keystore_type', deploy_keystore_type | default(['pem'])) }}"
        deploy_user: "{{ compiled_cert_plan.get(rn_cert, {}).get('deploy_user', deploy_user | default('wasadmin')) }}"
        deploy_group: "{{ compiled_cert_plan.get(rn_cert, {}).get('deploy_group', deploy_group | default('was')) }}"
        deploy_dir: "{{ compiled_cert_plan.get(rn_cert, {}).get('deploy_dir', deploy_dir | default('/home/user/Ansible_renewedCerts')) }}"
        rn_deploy_hosts: "{{ compiled_cert_plan.get(rn_cert, {}).get('deploy_hosts', []) }}"

- name: renew | report
  when: renew_report | default(true) | bool
  import_tasks: renew_report.yml
  tags: [renew]

- name: renew | (chain) deploy after renew
  when: (deploy_after_renew | default(false) | bool)
  include_tasks: ../tasks/deploy.yml
  tags: [renew]

tasks/renew_standalone.yml
---
- name: renew(standalone) | defaults
  set_fact:
    __rn_prefix: "{{ venafi_policy_prefix | default('/ved/policy/Automated/certs') }}"
  run_once: true

- name: renew(standalone) | normalize items
  set_fact:
    __rn_items: >-
      {{
        (renew_standalone_items | default([]))
        if ((renew_standalone_items | default([])) | length) > 0
        else
          (
            (renew_cert | default('')) | length > 0
            | ternary([{
               'cert': renew_cert,
               'pickup_id': (renew_pickup_id | default('')),
               'keystore_type': (deploy_keystore_type | default(['pem'])),
               'deploy_dir': (deploy_dir | default('/home/user/Ansible_renewedCerts')),
               'deploy_user': (deploy_user | default('wasadmin')),
               'deploy_group': (deploy_group | default('was')),
               'deploy_hosts': (deploy_hosts | default([]))
            }], [])
          )
      }}

- name: renew(standalone) | assert items
  assert:
    that:
      - __rn_items | length > 0
    fail_msg: "renew(standalone): provide renew_standalone_items or renew_cert* vars."

- name: renew(standalone) | per item
  loop: "{{ __rn_items }}"
  loop_control: { loop_var: rn, label: "{{ rn.cert }}" }
  include_tasks: renew_per_cert.yml
  vars:
    rn_cert: "{{ rn.cert }}"
    rn_pickup_id: "{{ (rn.pickup_id | default('')) | length > 0 | ternary(rn.pickup_id, (__rn_prefix ~ '/' ~ rn.cert)) }}"
    rn_force: "{{ renew_force | default(true) | bool }}"
    deploy_keystore_type: "{{ rn.keystore_type | default(['pem']) }}"
    deploy_user: "{{ rn.deploy_user | default('wasadmin') }}"
    deploy_group: "{{ rn.deploy_group | default('was') }}"
    deploy_dir: "{{ rn.deploy_dir | default('/home/user/Ansible_renewedCerts') }}"
    rn_deploy_hosts: "{{ rn.deploy_hosts | default([]) }}"

tasks/renew_per_cert.yml
---
- name: renew | ensure stats bucket
  set_stats:
    data:
      "{{ pipeline_stats_var }}": "{{ ((hostvars.get('localhost', {})).get(pipeline_stats_var, {})) | default({}) }}"
  run_once: true

- name: renew | probe precheck before-values
  set_fact:
    __pre_serial: "{{ ((hostvars.get('localhost', {})).get(pipeline_stats_var, {})).get('precheck', {}).get(rn_cert, {}).get('serial','') }}"
    __pre_days:   "{{ ((hostvars.get('localhost', {})).get(pipeline_stats_var, {})).get('precheck', {}).get(rn_cert, {}).get('days_remaining','') }}"
  run_once: true

- name: renew | compute before if missing
  set_fact:
    __need_compute_before: "{{ (__pre_serial | length) == 0 or (__pre_days | string | length) == 0 }}"
  run_once: true

- name: renew | pickup before if needed
  when: __need_compute_before
  command: >
    {{ vcert_bin }} pickup -id "{{ rn_pickup_id }}"
  register: __rn_pem_before_raw
  changed_when: false

- name: renew | strip vcert logs (before)
  when: __need_compute_before
  set_fact:
    __rn_pem_before: "{{ __rn_pem_before_raw.stdout | regex_replace('(?m)^vcert:.*\\n', '') }}"

- name: renew | compute before serial/days
  when: __need_compute_before
  block:
    - shell: |
        set -o pipefail
        printf "%s" "{{ __rn_pem_before | quote }}" | {{ openssl_bin }} x509 -noout -serial
      register: __rn_before_serial_cmd
      changed_when: false
    - shell: |
        set -o pipefail
        printf "%s" "{{ __rn_pem_before | quote }}" | {{ openssl_bin }} x509 -noout -enddate
      register: __rn_before_end_cmd
      changed_when: false
    - set_fact:
        __pre_serial: "{{ (__rn_before_serial_cmd.stdout | regex_replace('^serial=','') | trim) | default('') }}"
        __pre_days: >-
          {{
            (
              (
                ( (__rn_before_end_cmd.stdout | regex_replace('^notAfter=','')) | trim )
                | to_datetime('%b %d %H:%M:%S %Y %Z')
              ).timestamp() | int
              - (ansible_date_time.epoch | int)
            ) / 86400
          | round(0,'floor') | int }}

- name: renew | run vcert renew
  command: >
    {{ vcert_bin }} renew -id "{{ rn_pickup_id }}"
  register: __rn_renew
  changed_when: true

- name: renew | pickup after
  command: >
    {{ vcert_bin }} pickup -id "{{ rn_pickup_id }}"
  register: __rn_pem_after_raw
  changed_when: false

- name: renew | strip vcert logs (after)
  set_fact:
    __rn_pem_after: "{{ __rn_pem_after_raw.stdout | regex_replace('(?m)^vcert:.*\\n', '') }}"

- name: renew | compute post serial/days
  block:
    - shell: |
        set -o pipefail
        printf "%s" "{{ __rn_pem_after | quote }}" | {{ openssl_bin }} x509 -noout -serial
      register: __rn_after_serial_cmd
      changed_when: false
    - shell: |
        set -o pipefail
        printf "%s" "{{ __rn_pem_after | quote }}" | {{ openssl_bin }} x509 -noout -enddate
      register: __rn_after_end_cmd
      changed_when: false
    - set_fact:
        __post_serial: "{{ (__rn_after_serial_cmd.stdout | regex_replace('^serial=','') | trim) | default('') }}"
        __post_days: >-
          {{
            (
              (
                ( (__rn_after_end_cmd.stdout | regex_replace('^notAfter=','')) | trim )
                | to_datetime('%b %d %H:%M:%S %Y %Z')
              ).timestamp() | int
              - (ansible_date_time.epoch | int)
            ) / 86400
          | round(0,'floor') | int }}

- name: renew | publish stats
  set_stats:
    data:
      "{{ pipeline_stats_var }}": >-
        {{
          ((hostvars.get('localhost', {})).get(pipeline_stats_var, {}) | default({}))
          | combine({
              'renew': (
                ((hostvars.get('localhost', {})).get(pipeline_stats_var, {})).get('renew', {}) | combine({
                  (rn_cert): {
                    'pickup_id': rn_pickup_id,
                    'observed_before_serial': __pre_serial,
                    'observed_before_expiry_days': __pre_days,
                    'new_serial': __post_serial,
                    'new_expiry_days': __post_days,
                    'pem': __rn_pem_after,
                    'deploy_hosts': (rn_deploy_hosts | default([])),
                    'success': true
                  }
                }, recursive=True)
              )
            }, recursive=True)
        }}

tasks/renew_report.yml
---
- name: renew | build report context and send
  vars:
    __psvar: "{{ pipeline_stats_var }}"
    __stat: "{{ ((hostvars.get('localhost', {})).get(__psvar, {})).get('renew', {}) }}"
    __items_success: "{{ __stat | dict2items | selectattr('value.success','equalto', true) | list }}"
    __items_fail:    "{{ __stat | dict2items | rejectattr('value.success','equalto', true) | list }}"
    __rr_total: "{{ (__items_success|length + __items_fail|length) }}"
    __rr_ok:    "{{ __items_success | length }}"
    __rr_not_or_err: "{{ __items_fail | length }}"
  mail:
    host: "{{ smtp_host }}"
    port: "{{ smtp_port }}"
    to: "{{ user_email }}"
    subject: "Venafi Renewal Report"
    subtype: html
    body: "{{ lookup('template','report_renew.html.j2') }}"
  when: (user_email | length) > 0

tasks/deploy.yml
---
- name: deploy | resolve stats
  set_fact:
    __psvar: "{{ (pipeline_stats_var | default('venafi_pipeline_stats')) | string }}"
    __psobj: "{{ ((hostvars | default({})).get('localhost', {})).get(__psvar, {}) }}"
    __stats_available: "{{ (__psobj.get('renew', {}) | length) > 0 }}"
  run_once: true
  delegate_to: localhost
  tags: [deploy]

- name: deploy | effective mode
  set_fact:
    deploy_mode_effective: >-
      {{
        (deploy_mode if (deploy_mode | default('auto')) in ['auto','stats','standalone'] else 'auto')
        | ternary(
            (deploy_mode | default('auto')) == 'auto',
            ('stats' if __stats_available else 'standalone'),
            (deploy_mode | default('auto'))
          )
      }}
  run_once: true
  delegate_to: localhost
  tags: [deploy]

- name: deploy | from stats
  when: deploy_mode_effective == 'stats'
  import_tasks: deploy_from_stats.yml
  tags: [deploy]

- name: deploy | standalone
  when: deploy_mode_effective == 'standalone'
  import_tasks: deploy_standalone.yml
  tags: [deploy]

tasks/deploy_from_stats.yml
---
- name: deploy(stats) | renew map
  set_fact:
    __renew_map: "{{ __psobj.get('renew', {}) }}"
  run_once: true
  delegate_to: localhost

- name: deploy(stats) | choose certs
  set_fact:
    __deploy_certs: >-
      {{
        (deploy_cert_names | default([])) if ((deploy_cert_names | default([])) | length > 0)
        else (
          __renew_map | dict2items
          | selectattr('value.success','defined')
          | selectattr('value.success','equalto', true)
          | map(attribute='key') | list
        )
      }}
  run_once: true
  delegate_to: localhost

- name: deploy(stats) | assert certs present
  assert:
    that: [ "__deploy_certs | length > 0" ]
    fail_msg: "deploy(stats): no certs to deploy."
  run_once: true

- name: deploy(stats) | ensure stage root
  file:
    path: "{{ deploy_stage_root | default('/tmp/venafi_deploy') }}"
    state: directory
    mode: "0750"
  run_once: true
  delegate_to: localhost

- name: deploy(stats) | stage PEM per cert
  loop: "{{ __deploy_certs }}"
  loop_control: { loop_var: cert }
  block:
    - file:
        path: "{{ deploy_stage_root | default('/tmp/venafi_deploy') }}/{{ cert }}"
        state: directory
        mode: "0750"
      delegate_to: localhost
    - copy:
        dest: "{{ deploy_stage_root | default('/tmp/venafi_deploy') }}/{{ cert }}/{{ cert }}.pem"
        content: "{{ __renew_map[cert].pem | default('') }}"
        mode: "0640"
      delegate_to: localhost

- name: deploy(stats) | build rows (plan → stats → matrix)
  vars:
    _def_user:  "{{ deploy_user | default('wasadmin') }}"
    _def_group: "{{ deploy_group | default('was') }}"
    _def_dir:   "{{ deploy_dir | default('/home/user/Ansible_renewedCerts') }}"
    _def_types: "{{ deploy_keystore_type | default(['pem']) }}"
  set_fact:
    __plan_rows: []
  run_once: true
  delegate_to: localhost

- name: deploy(stats) | accumulate rows
  loop: "{{ __deploy_certs }}"
  loop_control: { loop_var: cert }
  set_fact:
    __plan_rows: >-
      {{
        __plan_rows + [
          dict(
            cert = cert,
            hosts = (
              compiled_cert_plan.get(cert, {}).get('deploy_hosts', [])
              if (compiled_cert_plan is defined and (compiled_cert_plan | length) > 0)
              else []
            )
            | default( __renew_map.get(cert, {}).get('deploy_hosts', []), true )
            | default( (cert_deploy_matrix | default({})).get(cert, {}).get('hosts', []), true ),
            dir = ( (cert_deploy_matrix | default({})).get(cert, {}).get('dir', _def_dir) ),
            user = ( (cert_deploy_matrix | default({})).get(cert, {}).get('user', _def_user) ),
            group = ( (cert_deploy_matrix | default({})).get(cert, {}).get('group', _def_group) ),
            keystore_type = ( (cert_deploy_matrix | default({})).get(cert, {}).get('keystore_type', _def_types) )
          )
        ]
      }}
  run_once: true
  delegate_to: localhost

- name: deploy(stats) | assert hosts
  assert:
    that:
      - (__plan_rows | selectattr('hosts','defined') | selectattr('hosts','length') | list | length) == (__plan_rows | length)
    fail_msg: "deploy(stats): some certs have no deploy hosts from plan/stats/matrix."
  run_once: true

- name: deploy(stats) | ship to targets (PEM)
  loop: "{{ __plan_rows }}"
  loop_control: { loop_var: row, label: "{{ row.cert }}" }
  block:
    - name: ensure dir on each host
      loop: "{{ row.hosts }}"
      loop_control: { loop_var: h }
      become: true
      file:
        path: "{{ row.dir }}"
        state: directory
        owner: "{{ row.user }}"
        group: "{{ row.group }}"
        mode: "0750"
      delegate_to: "{{ h }}"

    - name: copy PEM
      loop: "{{ row.hosts }}"
      loop_control: { loop_var: h }
      become: true
      copy:
        src: "{{ (deploy_stage_root | default('/tmp/venafi_deploy')) }}/{{ row.cert }}/{{ row.cert }}.pem"
        dest: "{{ row.dir }}/{{ row.cert }}.pem"
        owner: "{{ row.user }}"
        group: "{{ row.group }}"
        mode: "0640"
      delegate_to: "{{ h }}"

tasks/deploy_standalone.yml
---
- name: deploy(standalone) | stage root
  set_fact:
    __stage_root: "{{ deploy_stage_root | default('/tmp/venafi_deploy') }}"

- name: deploy(standalone) | normalize inputs
  set_fact:
    __sd_items: >-
      {{
        (deploy_standalone_items | default([]))
        if ((deploy_standalone_items | default([])) | length > 0)
        else
          (
            ((deploy_cert | default('')) | length) > 0
            | ternary(
                [ {
                    'cert': deploy_cert,
                    'hosts': (deploy_hosts | default([])),
                    'dir':   (deploy_dir   | default('')),
                    'user':  (deploy_user  | default('')),
                    'group': (deploy_group | default('')),
                    'keystore_type': (deploy_keystore_type | default(['pem'])),
                    'pem_content': (deploy_pem_content | default('')),
                    'pem_src':     (deploy_pem_src     | default('')),
                    'pfx_src':     (deploy_pfx_src     | default('')),
                    'jks_src':     (deploy_jks_src     | default(''))
                  } ],
                [] )
          )
      }}

- name: deploy(standalone) | assert items
  assert:
    that:
      - __sd_items | length > 0
    fail_msg: "deploy(standalone): provide deploy_standalone_items or legacy deploy_* vars."

- name: deploy(standalone) | validate items
  vars:
    _types: "{{ item.keystore_type | default(['pem']) }}"
    _pem_ok: "{{ (item.pem_content | default('') | length) > 0 or (item.pem_src | default('') | length) > 0 }}"
  loop: "{{ __sd_items }}"
  loop_control: { loop_var: item, label: "{{ item.cert | default('UNKNOWN') }}" }
  assert:
    that:
      - (item.cert | default('') | length) > 0
      - (item.hosts | default([]) | length) > 0
      - (item.dir | default('') | length) > 0
      - (item.user | default('') | length) > 0
      - (item.group | default('') | length) > 0
      - (_types | length) > 0
      - (('pem' not in _types) or _pem_ok)
      - (('pfx' not in _types) or ((item.pfx_src | default('') | length) > 0))
      - (('jks' not in _types) or ((item.jks_src | default('') | length) > 0))

- name: deploy(standalone) | ensure stage root
  file:
    path: "{{ __stage_root }}"
    state: directory
    mode: "0750"
  delegate_to: localhost
  run_once: true

- name: deploy(standalone) | stage artifacts (PEM)
  loop: "{{ __sd_items }}"
  loop_control: { loop_var: sd, label: "{{ sd.cert }}" }
  block:
    - file:
        path: "{{ __stage_root }}/{{ sd.cert }}"
        state: directory
        mode: "0750"
      delegate_to: localhost

    - name: stage PEM (content)
      when: "'pem' in (sd.keystore_type | default(['pem'])) and (sd.pem_content | default('') | length) > 0"
      copy:
        dest: "{{ __stage_root }}/{{ sd.cert }}/{{ sd.cert }}.pem"
        content: "{{ sd.pem_content }}"
        mode: "0640"
      delegate_to: localhost

    - name: stage PEM (src)
      when: "'pem' in (sd.keystore_type | default(['pem'])) and (sd.pem_content | default('') | length) == 0"
      copy:
        src: "{{ sd.pem_src }}"
        dest: "{{ __stage_root }}/{{ sd.cert }}/{{ sd.cert }}.pem"
        mode: "0640"
        remote_src: false
      delegate_to: localhost

- name: deploy(standalone) | copy to targets (PEM)
  loop: "{{ __sd_items }}"
  loop_control: { loop_var: sd, label: "{{ sd.cert }}" }
  block:
    - name: ensure dir on each host
      loop: "{{ sd.hosts }}"
      loop_control: { loop_var: h }
      become: true
      file:
        path: "{{ sd.dir }}"
        state: directory
        owner: "{{ sd.user }}"
        group: "{{ sd.group }}"
        mode: "0750"
      delegate_to: "{{ h }}"

    - name: copy PEM
      loop: "{{ sd.hosts }}"
      loop_control: { loop_var: h }
      become: true
      copy:
        src: "{{ __stage_root }}/{{ sd.cert }}/{{ sd.cert }}.pem"
        dest: "{{ sd.dir }}/{{ sd.cert }}.pem"
        owner: "{{ sd.user }}"
        group: "{{ sd.group }}"
        mode: "0640"
      delegate_to: "{{ h }}"

Templates (still placeholders)
templates/report_dry.html.j2
<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><title>Venafi Precheck Report</title></head>
<body>
  <h2>Venafi Precheck Report</h2>
  <p>Replace with your Outlook-friendly template.</p>
</body>
</html>

templates/report_renew.html.j2
<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><title>Venafi Renewal Report</title></head>
<body>
  <h2>Venafi Renewal Report</h2>
  <p>Replace with your Outlook-friendly template.</p>
</body>
</html>

Features summary (what you now have)
Gather/Compile (first)

Scans groups['all'] for venafi_renew_certs

Creates compiled_cert_plan with:

pickup_id, renew_days, keystore_type, deploy_dir, deploy_user, deploy_group, cert_app_config, deploy_hosts

Publishes artifacts into:

venafi_pipeline_intent.compiled_cert_plan

venafi_pipeline_intent.cert_names

venafi_pipeline_intent.compile_conflicts

venafi_pipeline_intent.compile_conflict_hints

Conflict handling

Deterministic resolution + optional fail

Provides actionable hints to cleanup inventory design

Precheck / Renew / Deploy

Same behavior you already validated

Uses plan/stats/standalone inputs

End-to-end pipeline works in AWX with “Pass artifacts”

If you want the next upgrade, I can integrate the conflict hints into the renew/precheck HTML reports so your email shows:

conflicts count

top 5 conflicts

“what to fix” guidance per conflict (Outlook-friendly table)
